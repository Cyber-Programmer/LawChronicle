{"ast":null,"code":"// Phase 5 API service for statute grouping operations\n\nconst API_BASE = 'http://localhost:8000/api/v1/phase5';\nexport class Phase5ApiService {\n  static getAuthToken() {\n    return localStorage.getItem('token');\n  }\n  static async makeRequest(endpoint, options = {}) {\n    const token = this.getAuthToken();\n    const response = await fetch(`${API_BASE}${endpoint}`, {\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...(token && {\n          'Authorization': `Bearer ${token}`\n        }),\n        ...options.headers\n      }\n    });\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({\n        detail: 'Unknown error'\n      }));\n      throw new Error(errorData.detail || `Request failed: ${response.statusText}`);\n    }\n    return response.json();\n  }\n\n  // Get current Phase 5 status\n  static async getStatus() {\n    return this.makeRequest('/status');\n  }\n\n  // Start the grouping process\n  static async startGrouping(request = {}) {\n    return this.makeRequest('/start-grouping', {\n      method: 'POST',\n      body: JSON.stringify(request)\n    });\n  }\n\n  // Get progress stream using Server-Sent Events\n  static createProgressStream() {\n    const token = this.getAuthToken();\n    const url = new URL(`${API_BASE}/progress-stream`);\n    if (token) {\n      url.searchParams.append('token', token);\n    }\n    return new EventSource(url.toString());\n  }\n\n  // Get grouped statutes (paginated)\n  static async getGroups(page = 1, limit = 20, filters) {\n    const params = new URLSearchParams({\n      page: page.toString(),\n      limit: limit.toString()\n    });\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        if (value) params.append(key, value);\n      });\n    }\n    return this.makeRequest(`/groups?${params}`);\n  }\n\n  // Get statutes within a specific group\n  static async getGroupedStatutes(groupId, page = 1, limit = 20) {\n    const params = new URLSearchParams({\n      page: page.toString(),\n      limit: limit.toString()\n    });\n    return this.makeRequest(`/groups/${groupId}/statutes?${params}`);\n  }\n\n  // Clear all grouping data (for development/testing)\n  static async clearGroups() {\n    return this.makeRequest('/clear', {\n      method: 'POST'\n    });\n  }\n\n  // Get grouping statistics\n  static async getStatistics() {\n    return this.makeRequest('/statistics');\n  }\n\n  // Export grouped data\n  static async exportGroups(format = 'json') {\n    const token = this.getAuthToken();\n    const response = await fetch(`${API_BASE}/export?format=${format}`, {\n      headers: {\n        ...(token && {\n          'Authorization': `Bearer ${token}`\n        })\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Export failed: ${response.statusText}`);\n    }\n    return response.blob();\n  }\n\n  // Get available collections\n  static async getCollections() {\n    const response = await this.makeRequest('/collections');\n    return response.data;\n  }\n\n  // Get available provinces\n  static async getProvinces() {\n    const response = await this.makeRequest('/provinces');\n    return response.data;\n  }\n\n  // ===== ENHANCED INTELLIGENT ANALYSIS METHODS =====\n\n  // Analyze a single statute for constitutional lineage and legal context\n  static async analyzeStatute(statute) {\n    const response = await this.makeRequest('/analyze-statute', {\n      method: 'POST',\n      body: JSON.stringify({\n        statute\n      })\n    });\n    return response.data;\n  }\n\n  // Detect amendment chains in a collection\n  static async detectAmendmentChains(collectionName) {\n    const response = await this.makeRequest('/detect-amendment-chains', {\n      method: 'POST',\n      body: JSON.stringify({\n        collection_name: collectionName\n      })\n    });\n    return response.data;\n  }\n\n  // Get detailed statistics for a collection\n  static async getCollectionStatistics(collectionName) {\n    const response = await this.makeRequest(`/statistics/${encodeURIComponent(collectionName)}`);\n    return response.data;\n  }\n\n  // Export groups with enhanced options\n  static async exportGroupsEnhanced(format, collectionName, includeAnalysis = false, filters) {\n    const response = await this.makeRequest('/export-groups', {\n      method: 'POST',\n      body: JSON.stringify({\n        format,\n        collection_name: collectionName,\n        include_analysis: includeAnalysis,\n        filters\n      })\n    });\n    return response.data;\n  }\n\n  // Batch analyze multiple statutes\n  static async batchAnalyzeStatutes(statutes, batchSize = 5) {\n    const results = [];\n    for (let i = 0; i < statutes.length; i += batchSize) {\n      const batch = statutes.slice(i, i + batchSize);\n      const batchPromises = batch.map(statute => this.analyzeStatute(statute).catch(error => {\n        console.warn(`Failed to analyze statute ${statute._id}:`, error);\n        return null; // Return null for failed analyses\n      }));\n      const batchResults = await Promise.all(batchPromises);\n      results.push(...batchResults.filter(result => result !== null));\n\n      // Add small delay between batches to avoid overwhelming the API\n      if (i + batchSize < statutes.length) {\n        await new Promise(resolve => setTimeout(resolve, 500));\n      }\n    }\n    return results;\n  }\n\n  // Download file helper for exports\n  static async downloadExport(exportData, filename, format) {\n    try {\n      let content;\n      let mimeType;\n      if (format === 'json') {\n        content = JSON.stringify(exportData, null, 2);\n        mimeType = 'application/json';\n      } else {\n        // csv\n        content = this.convertToCSV(exportData.groups || exportData);\n        mimeType = 'text/csv';\n      }\n      const blob = new Blob([content], {\n        type: mimeType\n      });\n      const url = window.URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `${filename}.${format}`;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      window.URL.revokeObjectURL(url);\n    } catch (error) {\n      console.error('Failed to download export:', error);\n      throw error;\n    }\n  }\n\n  // Convert data to CSV format\n  static convertToCSV(data) {\n    if (!data || !Array.isArray(data) || data.length === 0) {\n      return '';\n    }\n\n    // Get headers from first object\n    const headers = Object.keys(data[0]);\n    const csvRows = [];\n\n    // Add header row\n    csvRows.push(headers.join(','));\n\n    // Add data rows\n    for (const row of data) {\n      const values = headers.map(header => {\n        const value = row[header];\n        // Handle values that might contain commas or quotes\n        if (typeof value === 'string' && (value.includes(',') || value.includes('\"'))) {\n          return `\"${value.replace(/\"/g, '\"\"')}\"`;\n        }\n        return value || '';\n      });\n      csvRows.push(values.join(','));\n    }\n    return csvRows.join('\\n');\n  }\n}","map":{"version":3,"names":["API_BASE","Phase5ApiService","getAuthToken","localStorage","getItem","makeRequest","endpoint","options","token","response","fetch","headers","ok","errorData","json","catch","detail","Error","statusText","getStatus","startGrouping","request","method","body","JSON","stringify","createProgressStream","url","URL","searchParams","append","EventSource","toString","getGroups","page","limit","filters","params","URLSearchParams","Object","entries","forEach","key","value","getGroupedStatutes","groupId","clearGroups","getStatistics","exportGroups","format","blob","getCollections","data","getProvinces","analyzeStatute","statute","detectAmendmentChains","collectionName","collection_name","getCollectionStatistics","encodeURIComponent","exportGroupsEnhanced","includeAnalysis","include_analysis","batchAnalyzeStatutes","statutes","batchSize","results","i","length","batch","slice","batchPromises","map","error","console","warn","_id","batchResults","Promise","all","push","filter","result","resolve","setTimeout","downloadExport","exportData","filename","content","mimeType","convertToCSV","groups","Blob","type","window","createObjectURL","link","document","createElement","href","download","appendChild","click","removeChild","revokeObjectURL","Array","isArray","keys","csvRows","join","row","values","header","includes","replace"],"sources":["D:/DigiFloat/LawChronicle/frontend/src/components/phase5/apiService.ts"],"sourcesContent":["// Phase 5 API service for statute grouping operations\r\n\r\nimport type { \r\n  Phase5Status, \r\n  StartGroupingRequest, \r\n  StartGroupingResponse,\r\n  GroupsResponse,\r\n  GroupedStatutesResponse\r\n} from './types';\r\n\r\nconst API_BASE = 'http://localhost:8000/api/v1/phase5';\r\n\r\nexport class Phase5ApiService {\r\n  private static getAuthToken(): string | null {\r\n    return localStorage.getItem('token');\r\n  }\r\n\r\n  private static async makeRequest<T>(\r\n    endpoint: string, \r\n    options: RequestInit = {}\r\n  ): Promise<T> {\r\n    const token = this.getAuthToken();\r\n    const response = await fetch(`${API_BASE}${endpoint}`, {\r\n      ...options,\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        ...(token && { 'Authorization': `Bearer ${token}` }),\r\n        ...options.headers,\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));\r\n      throw new Error(errorData.detail || `Request failed: ${response.statusText}`);\r\n    }\r\n\r\n    return response.json();\r\n  }\r\n\r\n  // Get current Phase 5 status\r\n  static async getStatus(): Promise<Phase5Status> {\r\n    return this.makeRequest<Phase5Status>('/status');\r\n  }\r\n\r\n  // Start the grouping process\r\n  static async startGrouping(request: StartGroupingRequest = {}): Promise<StartGroupingResponse> {\r\n    return this.makeRequest<StartGroupingResponse>('/start-grouping', {\r\n      method: 'POST',\r\n      body: JSON.stringify(request),\r\n    });\r\n  }\r\n\r\n  // Get progress stream using Server-Sent Events\r\n  static createProgressStream(): EventSource {\r\n    const token = this.getAuthToken();\r\n    const url = new URL(`${API_BASE}/progress-stream`);\r\n    if (token) {\r\n      url.searchParams.append('token', token);\r\n    }\r\n    return new EventSource(url.toString());\r\n  }\r\n\r\n  // Get grouped statutes (paginated)\r\n  static async getGroups(\r\n    page: number = 1, \r\n    limit: number = 20,\r\n    filters?: {\r\n      province?: string;\r\n      statute_type?: string;\r\n      base_name?: string;\r\n    }\r\n  ): Promise<GroupsResponse> {\r\n    const params = new URLSearchParams({\r\n      page: page.toString(),\r\n      limit: limit.toString(),\r\n    });\r\n\r\n    if (filters) {\r\n      Object.entries(filters).forEach(([key, value]) => {\r\n        if (value) params.append(key, value);\r\n      });\r\n    }\r\n\r\n    return this.makeRequest<GroupsResponse>(`/groups?${params}`);\r\n  }\r\n\r\n  // Get statutes within a specific group\r\n  static async getGroupedStatutes(\r\n    groupId: string,\r\n    page: number = 1,\r\n    limit: number = 20\r\n  ): Promise<GroupedStatutesResponse> {\r\n    const params = new URLSearchParams({\r\n      page: page.toString(),\r\n      limit: limit.toString(),\r\n    });\r\n\r\n    return this.makeRequest<GroupedStatutesResponse>(`/groups/${groupId}/statutes?${params}`);\r\n  }\r\n\r\n  // Clear all grouping data (for development/testing)\r\n  static async clearGroups(): Promise<{ success: boolean; message: string }> {\r\n    return this.makeRequest('/clear', {\r\n      method: 'POST',\r\n    });\r\n  }\r\n\r\n  // Get grouping statistics\r\n  static async getStatistics(): Promise<{\r\n    total_groups: number;\r\n    total_statutes: number;\r\n    groups_by_province: Record<string, number>;\r\n    groups_by_type: Record<string, number>;\r\n    average_versions_per_group: number;\r\n  }> {\r\n    return this.makeRequest('/statistics');\r\n  }\r\n\r\n  // Export grouped data\r\n  static async exportGroups(format: 'json' | 'csv' = 'json'): Promise<Blob> {\r\n    const token = this.getAuthToken();\r\n    const response = await fetch(`${API_BASE}/export?format=${format}`, {\r\n      headers: {\r\n        ...(token && { 'Authorization': `Bearer ${token}` }),\r\n      },\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Export failed: ${response.statusText}`);\r\n    }\r\n\r\n    return response.blob();\r\n  }\r\n\r\n  // Get available collections\r\n  static async getCollections(): Promise<{ collections: string[] }> {\r\n    const response = await this.makeRequest<{ success: boolean; data: { collections: string[] } }>('/collections');\r\n    return response.data;\r\n  }\r\n\r\n  // Get available provinces\r\n  static async getProvinces(): Promise<{ provinces: string[] }> {\r\n    const response = await this.makeRequest<{ success: boolean; data: { provinces: string[] } }>('/provinces');\r\n    return response.data;\r\n  }\r\n\r\n  // ===== ENHANCED INTELLIGENT ANALYSIS METHODS =====\r\n\r\n  // Analyze a single statute for constitutional lineage and legal context\r\n  static async analyzeStatute(statute: any): Promise<{\r\n    constitutional_analysis: any;\r\n    legal_context: any;\r\n    statute_id: string;\r\n    analysis_timestamp: string;\r\n  }> {\r\n    const response = await this.makeRequest<{ \r\n      success: boolean; \r\n      data: {\r\n        constitutional_analysis: any;\r\n        legal_context: any;\r\n        statute_id: string;\r\n        analysis_timestamp: string;\r\n      }\r\n    }>('/analyze-statute', {\r\n      method: 'POST',\r\n      body: JSON.stringify({ statute }),\r\n    });\r\n    return response.data;\r\n  }\r\n\r\n  // Detect amendment chains in a collection\r\n  static async detectAmendmentChains(collectionName: string): Promise<{\r\n    chains: any[];\r\n    total_chains: number;\r\n    collection_name: string;\r\n    analysis_timestamp: string;\r\n  }> {\r\n    const response = await this.makeRequest<{ \r\n      success: boolean; \r\n      data: {\r\n        chains: any[];\r\n        total_chains: number;\r\n        collection_name: string;\r\n        analysis_timestamp: string;\r\n      }\r\n    }>('/detect-amendment-chains', {\r\n      method: 'POST',\r\n      body: JSON.stringify({ collection_name: collectionName }),\r\n    });\r\n    return response.data;\r\n  }\r\n\r\n  // Get detailed statistics for a collection\r\n  static async getCollectionStatistics(collectionName: string): Promise<{\r\n    total_statutes: number;\r\n    province_distribution: Array<{ province: string; count: number }>;\r\n    type_distribution: Array<{ type: string; count: number }>;\r\n    year_distribution: Array<{ year: string; count: number }>;\r\n    collection_name: string;\r\n    timestamp: string;\r\n    constitutional_amendments?: number;\r\n    amendment_chains?: number;\r\n  }> {\r\n    const response = await this.makeRequest<{ \r\n      success: boolean; \r\n      data: any \r\n    }>(`/statistics/${encodeURIComponent(collectionName)}`);\r\n    return response.data;\r\n  }\r\n\r\n  // Export groups with enhanced options\r\n  static async exportGroupsEnhanced(\r\n    format: 'json' | 'csv',\r\n    collectionName: string,\r\n    includeAnalysis: boolean = false,\r\n    filters?: any\r\n  ): Promise<{\r\n    export_timestamp: string;\r\n    collection_name: string;\r\n    format: string;\r\n    include_analysis: boolean;\r\n    groups: any[];\r\n    metadata: {\r\n      total_groups: number;\r\n      total_statutes: number;\r\n      export_version: string;\r\n    };\r\n  }> {\r\n    const response = await this.makeRequest<{ \r\n      success: boolean; \r\n      data: any \r\n    }>('/export-groups', {\r\n      method: 'POST',\r\n      body: JSON.stringify({\r\n        format,\r\n        collection_name: collectionName,\r\n        include_analysis: includeAnalysis,\r\n        filters\r\n      }),\r\n    });\r\n    return response.data;\r\n  }\r\n\r\n  // Batch analyze multiple statutes\r\n  static async batchAnalyzeStatutes(statutes: any[], batchSize: number = 5): Promise<any[]> {\r\n    const results = [];\r\n    \r\n    for (let i = 0; i < statutes.length; i += batchSize) {\r\n      const batch = statutes.slice(i, i + batchSize);\r\n      const batchPromises = batch.map(statute => \r\n        this.analyzeStatute(statute).catch(error => {\r\n          console.warn(`Failed to analyze statute ${statute._id}:`, error);\r\n          return null; // Return null for failed analyses\r\n        })\r\n      );\r\n      \r\n      const batchResults = await Promise.all(batchPromises);\r\n      results.push(...batchResults.filter(result => result !== null));\r\n      \r\n      // Add small delay between batches to avoid overwhelming the API\r\n      if (i + batchSize < statutes.length) {\r\n        await new Promise(resolve => setTimeout(resolve, 500));\r\n      }\r\n    }\r\n    \r\n    return results;\r\n  }\r\n\r\n  // Download file helper for exports\r\n  static async downloadExport(exportData: any, filename: string, format: 'json' | 'csv'): Promise<void> {\r\n    try {\r\n      let content: string;\r\n      let mimeType: string;\r\n\r\n      if (format === 'json') {\r\n        content = JSON.stringify(exportData, null, 2);\r\n        mimeType = 'application/json';\r\n      } else { // csv\r\n        content = this.convertToCSV(exportData.groups || exportData);\r\n        mimeType = 'text/csv';\r\n      }\r\n\r\n      const blob = new Blob([content], { type: mimeType });\r\n      const url = window.URL.createObjectURL(blob);\r\n      \r\n      const link = document.createElement('a');\r\n      link.href = url;\r\n      link.download = `${filename}.${format}`;\r\n      document.body.appendChild(link);\r\n      link.click();\r\n      document.body.removeChild(link);\r\n      \r\n      window.URL.revokeObjectURL(url);\r\n    } catch (error) {\r\n      console.error('Failed to download export:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Convert data to CSV format\r\n  private static convertToCSV(data: any[]): string {\r\n    if (!data || !Array.isArray(data) || data.length === 0) {\r\n      return '';\r\n    }\r\n\r\n    // Get headers from first object\r\n    const headers = Object.keys(data[0]);\r\n    const csvRows = [];\r\n\r\n    // Add header row\r\n    csvRows.push(headers.join(','));\r\n\r\n    // Add data rows\r\n    for (const row of data) {\r\n      const values = headers.map(header => {\r\n        const value = row[header];\r\n        // Handle values that might contain commas or quotes\r\n        if (typeof value === 'string' && (value.includes(',') || value.includes('\"'))) {\r\n          return `\"${value.replace(/\"/g, '\"\"')}\"`;\r\n        }\r\n        return value || '';\r\n      });\r\n      csvRows.push(values.join(','));\r\n    }\r\n\r\n    return csvRows.join('\\n');\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}